<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>[Nature of Code] Part 2: Fractals and Cellular Automata | Learning Automata</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="[Nature of Code] Part 2: Fractals and Cellular Automata" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Nature of Code note series" />
<meta property="og:description" content="Nature of Code note series" />
<link rel="canonical" href="http://blog.logancyang.com/note/natureofcode/simulation/processing/p5js/2020/07/23/fractals.html" />
<meta property="og:url" content="http://blog.logancyang.com/note/natureofcode/simulation/processing/p5js/2020/07/23/fractals.html" />
<meta property="og:site_name" content="Learning Automata" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-07-23T00:00:00-05:00" />
<script type="application/ld+json">
{"datePublished":"2020-07-23T00:00:00-05:00","dateModified":"2020-07-23T00:00:00-05:00","description":"Nature of Code note series","mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.logancyang.com/note/natureofcode/simulation/processing/p5js/2020/07/23/fractals.html"},"@type":"BlogPosting","url":"http://blog.logancyang.com/note/natureofcode/simulation/processing/p5js/2020/07/23/fractals.html","headline":"[Nature of Code] Part 2: Fractals and Cellular Automata","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://blog.logancyang.com/feed.xml" title="Learning Automata" /><!-- the google_analytics_id gets auto inserted from the config file -->



<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-164976898-2','auto');ga('require','displayfeatures');ga('send','pageview');</script>

<link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>[Nature of Code] Part 2: Fractals and Cellular Automata | Learning Automata</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="[Nature of Code] Part 2: Fractals and Cellular Automata" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Nature of Code note series" />
<meta property="og:description" content="Nature of Code note series" />
<link rel="canonical" href="http://blog.logancyang.com/note/natureofcode/simulation/processing/p5js/2020/07/23/fractals.html" />
<meta property="og:url" content="http://blog.logancyang.com/note/natureofcode/simulation/processing/p5js/2020/07/23/fractals.html" />
<meta property="og:site_name" content="Learning Automata" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-07-23T00:00:00-05:00" />
<script type="application/ld+json">
{"datePublished":"2020-07-23T00:00:00-05:00","dateModified":"2020-07-23T00:00:00-05:00","description":"Nature of Code note series","mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.logancyang.com/note/natureofcode/simulation/processing/p5js/2020/07/23/fractals.html"},"@type":"BlogPosting","url":"http://blog.logancyang.com/note/natureofcode/simulation/processing/p5js/2020/07/23/fractals.html","headline":"[Nature of Code] Part 2: Fractals and Cellular Automata","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<link href="https://unpkg.com/@primer/css/dist/primer.css" rel="stylesheet" />
<link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.7/css/all.css"><link type="application/atom+xml" rel="alternate" href="http://blog.logancyang.com/feed.xml" title="Learning Automata" /><!-- the google_analytics_id gets auto inserted from the config file -->



<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-164976898-2','auto');ga('require','displayfeatures');ga('send','pageview');</script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head><body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Learning Automata</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About Me</a><a class="page-link" href="/search/">Search</a><a class="page-link" href="/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">[Nature of Code] Part 2: Fractals and Cellular Automata</h1><p class="page-description">Nature of Code note series</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2020-07-23T00:00:00-05:00" itemprop="datePublished">
        Jul 23, 2020
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      10 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/categories/#note">note</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#natureofcode">natureofcode</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#simulation">simulation</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#processing">processing</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#p5js">p5js</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#fractals">Fractals</a>
<ul>
<li class="toc-entry toc-h3"><a href="#koch-curve-the-monster-curve">Koch curve: the “monster curve”</a></li>
<li class="toc-entry toc-h3"><a href="#binary-fractal-tree">Binary fractal tree</a>
<ul>
<li class="toc-entry toc-h4"><a href="#review-pushmatrix-and-popmatrix">Review: pushMatrix() and popMatrix()</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#l-systems-applying-recursion-to-text">L-Systems: applying recursion to text</a></li>
<li class="toc-entry toc-h3"><a href="#space-colonization">Space Colonization</a>
<ul>
<li class="toc-entry toc-h4"><a href="#a-variation-of-space-colonization">A Variation of Space Colonization</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#cellular-automata">Cellular Automata</a>
<ul>
<li class="toc-entry toc-h3"><a href="#game-of-life-2d">Game of Life (2D)</a></li>
<li class="toc-entry toc-h3"><a href="#some-more-possibilities">Some more possibilities</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#reference">Reference</a></li>
</ul><h2 id="fractals">
<a class="anchor" href="#fractals" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fractals</h2>

<p>The term <strong>fractal</strong> is coined by mathematician Benoit Mandelbrot in 1975. It means broken or fractured.</p>

<p><strong>A structure needs to have two properties to be a fractal:</strong></p>

<ol>
  <li><strong>Self-similarity: when you zoom in on it, it looks similar to (or exactly the same as) the whole.</strong></li>
  <li><strong>Fine structure at small scale.</strong></li>
  <li><strong>Generated from a recursive definition.</strong></li>
</ol>

<p>A binary tree with infinite depth is an example of exact fractal.</p>

<p>The stock price curve is an example of <strong>stochastic</strong> fractal. When you zoom in, the shape isn’t exactly the same, but it has the same quality, a quality of <em>squiggly randomness</em>. The coast line is another example.</p>

<p>A famous and extremely simple fractal pattern is the <a href="https://en.wikipedia.org/wiki/Cantor_set">Cantor Set</a>. It divides a line into 3 equal segments and remove the middle one. You get the Cantor set by doing this to every segment recursively.</p>

<h3 id="koch-curve-the-monster-curve">
<a class="anchor" href="#koch-curve-the-monster-curve" aria-hidden="true"><span class="octicon octicon-link"></span></a>Koch curve: the “monster curve”</h3>

<p>The generation rule of the Koch curve is very similar to the Cantor set:</p>

<ol>
  <li>Divide a line into 3 equal segments</li>
  <li>Remove the middle segment</li>
  <li>Replace the middle segment with an equilateral triangle</li>
  <li>Repeat this to all the line segments.</li>
</ol>

<p>In code, the way to do this is to use two lists, <code class="highlighter-rouge">current</code> and <code class="highlighter-rouge">next</code>. Pseudocode:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Start with current = [line0], next = []
i = 0
while i &lt; max_steps:

    for line in current:

        find all the points of interest on line: a, b, c, d, e
        (a is the left end, b is at the 1/3 mark, c is the tip of the triangle,
        d is the 2/3 mark, e is the right end)

        create the new line segments (ab, bc, cd, de) and add them to next

    current = next
    next = []
    i++
</code></pre></div></div>

<h3 id="binary-fractal-tree">
<a class="anchor" href="#binary-fractal-tree" aria-hidden="true"><span class="octicon octicon-link"></span></a>Binary fractal tree</h3>

<p>Generation rule:</p>

<ol>
  <li>Start with a vertical line, go to its tip</li>
  <li>At the tip in 1, rotate 45 degrees and draw a new line with half the length</li>
  <li>At the tip in 1, rotate -45 degrees and draw a new line with half the length</li>
  <li>Go to the tips of 2 and 3, repeat.</li>
</ol>

<p>In pseudocode,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>branch(next_length):
    drawLine(0, 0, 0, -next_length)
    translate(0, -next_length)

    len = next_length/2
    if len &gt; threshold:
        pushMatrix()
        rotate(theta)
        branch(len)
        popMatrix()

        pushMatrix()
        rotate(-theta)
        branch(len)
        popMatrix()
</code></pre></div></div>

<p>In each recursive step we call <code class="highlighter-rouge">branch()</code>.</p>

<h4 id="review-pushmatrix-and-popmatrix">
<a class="anchor" href="#review-pushmatrix-and-popmatrix" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review: <code class="highlighter-rouge">pushMatrix()</code> and <code class="highlighter-rouge">popMatrix()</code>
</h4>

<p>Notice that <code class="highlighter-rouge">pushMatrix()</code> creates a new reference frame that saves the current transformation (the current translate and rotate state).</p>

<p>To visualize a reference frame state, it can be represented by a unit vector which has the starting point at the <em>new</em> <code class="highlighter-rouge">(0, 0)</code> and pointing to the <em>new</em> <code class="highlighter-rouge">(0, 1)</code> direction.</p>

<p>Then <code class="highlighter-rouge">popMatrix()</code> can forget about all the transformations performed after the last <code class="highlighter-rouge">pushMatrix()</code>, and restore to the previous state. Thus it’s a <em>stack</em> of transformation “sandboxes”.</p>

<p>These are Processing terminology. In P5.js they are called <code class="highlighter-rouge">push()</code> and <code class="highlighter-rouge">pop()</code>.</p>

<h3 id="l-systems-applying-recursion-to-text">
<a class="anchor" href="#l-systems-applying-recursion-to-text" aria-hidden="true"><span class="octicon octicon-link"></span></a>L-Systems: applying recursion to text</h3>

<p>An <a href="https://en.wikipedia.org/wiki/L-system">L-system</a> or Lindenmayer system is a parallel rewriting system and a type of formal grammar. Lindenmayer introduced L-systems in 1968 to describe the behaviour of plant cells and to model the growth processes of plant development. L-systems have also been used to model the morphology of a variety of organisms and can be used to generate self-similar fractals.</p>

<p>An L-system has 3 components:</p>

<ol>
  <li>Alphabet: characters allowed in this L-system</li>
  <li>Axiom: an initial string</li>
  <li>Rule set: a mapping of character to its descendant(s)</li>
</ol>

<p>For instance, we have an L-system that has</p>

<ol>
  <li>Alphabet: A, B</li>
  <li>Axiom: A</li>
  <li>Rule set: A -&gt; ABA, B -&gt; BBB</li>
</ol>

<p>How does it work?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Gen 0: A

Gen 1: ABA

Gen 2: ABABBBABA

Gen 3: ABABBBABABBBBBBBBBABABBBABA

...
</code></pre></div></div>

<p>If we think about it as drawing things, set A to be drawing a line <code class="highlighter-rouge">-</code>, and B to be moving forward <code class="highlighter-rouge">_</code> (whitespace), then what is the effect above? Let’s see,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Gen 0: -

Gen 1: - -

Gen 2: - -   - -

Gen 3: - -   - -         - -   - -

...
</code></pre></div></div>

<p>We have recreated the <strong>Cantor set</strong>!!</p>

<p><strong>This means that we can design L-systems that create fractal patterns</strong>.</p>

<h3 id="space-colonization">
<a class="anchor" href="#space-colonization" aria-hidden="true"><span class="octicon octicon-link"></span></a>Space Colonization</h3>

<p><a href="http://algorithmicbotany.org/papers/colonization.egwnp2007.html">Space Colonization</a> is an algorithm that creates a fractal tree that grows by capturing pre-generated “leaves”. These leaves are usually generated randomly to fill up the space, and they attract the branches to grow towards them.</p>

<p>Here’s the pseudocode of this algorithm for 2D space.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Leaf:

    constructor():

        Create leaf with random 2D coordinates (x, y), and a boolean flag
        `reached`.

    show(): Render the leaf on canvas


class Branch:

    constructor(parent, position, direction):

        A branch is represented by its position, its parent branch's position,
        and a direction copied from its parent. This direction can be used to
        create new directions for its children.

        Properties of a Branch object:
            parent, pos, dir, originDir (keep track of parent's direction),
            count (# leaves that find this branch as closest),
            stepSize (a parameter to tune to grow faster or slower)

    reset(): Set the direction back to originDir (parent's direction),
        and count to 0.

    show(): If parent exists, render the line from parent position
        to position


class Tree:

    constructor():

        A Tree has properties: an array of leaves, # leaves, an array of
        branches, a maxDistance, and a minDistance.

        It needs to be initialized. The initialization contains several steps:

        - It needs a root as the 1st element in branches. This root is a Branch
        object with a position, direction and no parent.

        - All leaves need to be generated in a loop.

        - As a prerequisite of grow(), first the root needs to grow to the
        vicinity of some leaves in order for the leaves to attract them later.
        This process can use a while loop and a boolean variable `found`
        initialized to false. Set current branch to root. While not found:

            Loop through all leaves and check the distance to
            the current branch, if it's less than maxDistance, set found to
            true. If after all leaves, found is still false, grow a new branch
            on the current branch that has the same direction as current branch,
            and set this new branch to be the current branch.

        This way we can grow the root to the vicinity of some leaves and keeping
        its initial direction unchanged.

    grow():

        This is the key part of this space colonization algorithm.

        Loop through all leaves. For each leaf, loop through all branches and
        find its closest branch that is within the (minDistance, maxDistance)
        interval. This closestBranch is the one this particular leaf attracts.

        In the double for-loop, calculate the distance between the current pair
        of branch and leaf. If it's less than minDistance, set leaf.reached to
        true, and closestBranch to null. Else, compare this distance to the
        previous record min distance, if (it's lower or closestBranch is null),
        set closestBranch to current branch and update the record.

        After looping over all branches for a leaf, IT IS THE PART THAT
        GENERATES THE NEW BRANCH:

        - Get the vector (closestBranch -&gt; leaf), normalize it

        - Add this normalized vector to closestBranch's direction which will be
          used as the direction of its child branch. Note that this direction
          is cumulative with all previous or future leaves that share this
          closestBranch.

        - Increment clostBranch's count which keeps track of the number of
          leaves that share this closestBranch, in other words, influenced the
          cumulative direction.

        After the double for-loop that runs through all branches for all leaves,
        check all leaves with one more pass. If it's reached, remove it from
        the array. (JS Trick: to remove element while iterating on the same array,
        iterate backward)

        Next, iterate over all branches. If a branch has count &gt; 0, make a
        child branch from it using its updated direction. One trick to make the
        tree better looking is to shorten the length of a new branch if it's
        shared by a lot of leaves, by dividing its length by its count. Then,
        don't forget to reset the branch!

    show(): Call show() of all leaves and branches.

</code></pre></div></div>

<p>To help this tree reach more leaves, we can add a small random perturbation in direction whenever we grow a new branch.</p>

<p>You can check how this works in action <a href="https://logancyang.com/simulations/fractals/space_colonization.html">here on my website</a>.</p>

<h4 id="a-variation-of-space-colonization">
<a class="anchor" href="#a-variation-of-space-colonization" aria-hidden="true"><span class="octicon octicon-link"></span></a>A Variation of Space Colonization</h4>

<p>I find it satisfying to look at perpendicular lines in 3D space so I tweaked the above algorithm a bit to grow a fractal tree with branches in orthogonal directions, x, y and z. The place I tweaked is the new branch growing part.</p>

<p>The idea is simple. Here’s the pseudocode for the new branch generation part.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- Get the vector (closestBranch -&gt; leaf) as before, normalize it.
- Find the x, y, z component that has the largest magnitude, and set it to be
  the new direction
</code></pre></div></div>

<p>That’s it. The way to make it 3D is even simpler. Just add a <code class="highlighter-rouge">z</code> component to all geometry.</p>

<p>Check out the result <a href="https://logancyang.com/simulations/charting/charting.html">here</a>. I added the logic that once all branches are grown, skip the <code class="highlighter-rouge">grow()</code> method in the draw loop. However, since there are many branches in 3D space, the performance is still not very good. If you have suggestions to improve this, please let me know.</p>

<h2 id="cellular-automata">
<a class="anchor" href="#cellular-automata" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cellular Automata</h2>

<p>The most famous cellular automata algorithm is the Game of Life.</p>

<p>A cellular automaton has a grid of cells, each cell has</p>

<ul>
  <li>a state: dead (0) or alive (1)</li>
  <li>a neighborhood: adjacent cells</li>
</ul>

<p>The state of a cell at time <code class="highlighter-rouge">t</code> depends on its neighbors in <code class="highlighter-rouge">t-1</code>. So we have the concept of generations.</p>

<p>Wolfram classifies the possible outcomes of a cellular automaton into 4 types:</p>

<ol>
  <li>uniformity</li>
  <li>oscillation (repetition)</li>
  <li>random</li>
  <li>complexity</li>
</ol>

<p>With certains rules (such as <a href="https://en.wikipedia.org/wiki/Rule_30">rule 30</a>), even a 1D Game of Life can be a pseudorandom number generator.</p>

<p>You can check out the artilce that lists the rules on <a href="https://mathworld.wolfram.com/ElementaryCellularAutomaton.html">Wolfram’s website</a>. Some rules are particularly interesting. For example, rule 90 generates a Sierpinski Triangle which is a fractal!</p>

<h3 id="game-of-life-2d">
<a class="anchor" href="#game-of-life-2d" aria-hidden="true"><span class="octicon octicon-link"></span></a>Game of Life (2D)</h3>

<p>There are 3 scenarios in Game of Life</p>

<ol>
  <li>Death
    <ol>
      <li>Overpopulation</li>
      <li>Loneliness</li>
    </ol>
  </li>
  <li>Birth
    <ol>
      <li>Exactly 3 live neighbors</li>
    </ol>
  </li>
  <li>Stasis
    <ol>
      <li>In all other cases, stay the same</li>
    </ol>
  </li>
</ol>

<p>For the edges, we can either ignore them or wrap them around, i.e. treat position <code class="highlighter-rouge">-1</code> as position <code class="highlighter-rouge">length</code> for each row.</p>

<p>If you think about it, <strong>every digital image processing algorithm is a cellular automaton!</strong> Each pixel is essentially a cell. A convolution, for example, is a cellular automaton! So is a Gaussian blur, a ripple effect, and so on.</p>

<p>An interesting expansion to the simple black and white Game of Life is to make each cell an object and let it store its history. We can make it blue if it’s within N steps of birth, red if it’s within N steps of death, for instance.</p>

<h3 id="some-more-possibilities">
<a class="anchor" href="#some-more-possibilities" aria-hidden="true"><span class="octicon octicon-link"></span></a>Some more possibilities</h3>

<ol>
  <li>The cell could be non-rectangular, could be hexagonal, triangular, etc.</li>
  <li>Add probability, e.g. a rule of 80% of dying.</li>
  <li>Continuous states</li>
  <li>Image processing: an application to Cellular Automata, say, a water ripple effect.</li>
  <li>State history</li>
  <li>Moving cells. Change movement based on neighboring cells (flocking)</li>
  <li>Nested complex systems, say a cell is another CA.</li>
</ol>

<h2 id="reference">
<a class="anchor" href="#reference" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reference</h2>

<ul>
  <li>The Coding Train <a href="https://www.youtube.com/playlist?list=PLRqwX-V7Uu6bXUJvjnMWGU5SmjhI-OXef">videos</a>
</li>
</ul>

  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="logancyang/blog-learning-automata"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/note/natureofcode/simulation/processing/p5js/2020/07/23/fractals.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>Notes, code and essays by Logan Yang.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/logancyang" title="logancyang"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/logancyang" title="logancyang"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
